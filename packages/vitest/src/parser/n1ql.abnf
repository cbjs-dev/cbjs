;;;;;;;;;;
; TOKENS ;
;;;;;;;;;;


INT:           1*DIGIT;

NUM:           1*DIGIT '.' Digit+ Exponent? | Int Exponent;
BLOCK_COMMENT: '/*' .*? '*/';

LINE_COMMENT:  '--' ~[\n\r]*;
WHITESPACE:    [ \t\n\r\f\u00a0]+ -> skip;
DOT:           '.';
PLUS:          '+';
MINUS:         '-' | [mM][iI][nN][uU][sS];
STAR:          '*';
DIV:           '/';
MOD:           '%';
DEQ:           '==';
EQ:            '=';
NE:            '!=' | '<>';
LT:            '<';
LE:            '<=';
GT:            '>';
GE:            '>=';
CONCAT:        '||';
LPAREN:        '(';
RPAREN:        ')';
LBRACE:        '{';
RBRACE:        '}';
COMMA:         ',';
COLON:         ':';
LBRACKET:      '[';
RBRACKET:      ']';
RBRACKET_ICASE:']i';
SEMI:          ';';
NOT_A_TOKEN:   '!';

NAMESPACE_ID: [dD][eE][fF][aA][uU][lL][tT];

ADVISE:       [aA][dD][vV][iI][sS][eE];
ALL:          [aA][lL][lL];
ALTER:        [aA][lL][tT][eE][rR];
ANALYZE:      [aA][nN][aA][lL][yY][zZ][eE];
AND:          [aA][nN][dD];
ANY:          [aA][nN][yY];
ARRAY:        [aA][rR][rR][aA][yY];
AS:           [aA][sS];
ASC:          [aA][sS][cC];
AT:           [aA][tT];
BEGIN:        [bB][eE][gG][iI][nN];
BETWEEN:      [bB][eE][tT][wW][eE][eE][nN];
BINARY:       [bB][iI][nN][aA][rR][yY];
BOOLEAN:      [bB][oO][oO][lL][eE][aA][nN];
BREAK:        [bB][rR][eE][aA][kK];
BUCKET:       [bB][uU][cC][kK][eE][tT];
BUILD:        [bB][uU][iI][lL][dD];
BY:           [bB][yY];
CALL:         [cC][aA][lL][lL];
CASE:         [cC][aA][sS][eE];
CAST:         [cC][aA][sS][tT];
CLUSTER:      [cC][lL][uU][sS][tT][eE][rR];
COLLATE:      [cC][oO][lL][lL][aA][tT][eE];
COLLECTION:   [cC][oO][lL][lL][eE][cC][tT][iI][oO][nN];
COMMIT:       [cC][oO][mM][mM][iI][tT];
COMMITTED:    [cC][oO][mM][mM][iI][tT][tT][eE][dD];
CONNECT:      [cC][oO][nN][nN][eE][cC][tT];
CONTINUE:     [cC][oO][nN][tT][iI][nN][uU][eE];
CORRELATED:   [cC][oO][rR][rR][eE][lL][aA][tT][eE][dD];
COVER:        [cC][oO][vV][eE][rR];
CREATE:       [cC][rR][eE][aA][tT][eE];
CURRENT:      [cC][uU][rR][rR][eE][nN][tT];
DATABASE:     [dD][aA][tT][aA][bB][aA][sS][eE];
DATASET:      [dD][aA][tT][aA][sS][eE][tT];
DATASTORE:    [dD][aA][tT][aA][sS][tT][oO][rR][eE];
DECLARE:      [dD][eE][cC][lL][aA][rR][eE];
DECREMENT:    [dD][eE][cC][rR][eE][mM][eE][nN][tT];
DELETE_:      [dD][eE][lL][eE][tT][eE];
DERIVED:      [dD][eE][rR][iI][vV][eE][dD];
DESC:         [dD][eE][sS][cC];
DESCRIBE:     [dD][eE][sS][cC][rR][iI][bB][eE];
DISTINCT:     [dD][iI][sS][tT][iI][nN][cC][tT];
DO:           [dD][oO];
DROP:         [dD][rR][oO][pP];
EACH:         [eE][aA][cC][hH];
ELEMENT:      [eE][lL][eE][mM][eE][nN][tT];
ELSE:         [eE][lL][sS][eE];
END:          [eE][nN][dD];
EVERY:        [eE][vV][eE][rR][yY];
EXCEPT:       [eE][xX][cC][eE][pP][tT];
EXCLUDE:      [eE][xX][cC][lL][uU][dD][eE];
EXECUTE:      [eE][xX][eE][cC][uU][tT][eE];
EXISTS:       [eE][xX][iI][sS][tT][sS];
EXPLAIN:      [eE][xX][pP][lL][aA][iI][nN];
FALSE:        [fF][aA][lL][sS][eE];
FETCH:        [fF][eE][tT][cC][hH];
FILTER:       [fF][iI][lL][tT][eE][rR];
FIRST:        [fF][iI][rR][sS][tT];
FLATTEN:      [fF][lL][aA][tT][tT][eE][nN];
FLUSH:        [fF][lL][uU][sS][hH];
FOLLOWING:    [fF][oO][lL][lL][oO][wW][iI][nN][gG];
FOR:          [fF][oO][rR];
FORCE:        [fF][oO][rR][cC][eE];
FROM:         [fF][rR][oO][mM];
FTS:          [fF][tT][sS];
FUNCTION:     [fF][uU][nN][cC][tT][iI][oO][nN];
GOLANG:       [gG][oO][lL][aA][nN][gG];
GRANT:        [gG][rR][aA][nN][tT];
GROUP:        [gG][rR][oO][uU][pP];
GROUPS:       [gG][rR][oO][uU][pP][sS];
GSI:          [gG][sS][iI];
HASH:         [hH][aA][sS][hH];
HAVING:       [hH][aA][vV][iI][nN][gG];
IF:           [iI][fF];
IGNORE:       [iI][gG][nN][oO][rR][eE];
ILIKE:        [iI][lL][iI][kK][eE];
IN:           [iI][nN];
INCLUDE:      [iI][nN][cC][lL][uU][dD][eE];
INCREMENT:    [iI][nN][cC][rR][eE][mM][eE][nN][tT];
INDEX:        [iI][nN][dD][eE][xX];
INFER:        [iI][nN][fF][eE][rR];
INLINE:       [iI][nN][lL][iI][nN][eE];
INNER:        [iI][nN][nN][eE][rR];
INSERT:       [iI][nN][sS][eE][rR][tT];
INTERSECT:    [iI][nN][tT][eE][rR][sS][eE][cC][tT];
INTO:         [iI][nN][tT][oO];
IS:           [iI][sS];
ISOLATION:    [iI][sS][oO][lL][aA][tT][iI][oO][nN];
JAVASCRIPT:   [jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT];
JOIN:         [jJ][oO][iI][nN];
KEY:          [kK][eE][yY];
KEYS:         [kK][eE][yY][sS];
KEYSPACE:     [kK][eE][yY][sS][pP][aA][cC][eE];
KNOWN:        [kK][nN][oO][wW][nN];
LANGUAGE:     [lL][aA][nN][gG][uU][aA][gG][eE];
LAST:         [lL][aA][sS][tT];
LEFT:         [lL][eE][fF][tT];
LET_:          [lL][eE][tT];
LETTING:      [lL][eE][tT][tT][iI][nN][gG];
LEVEL:        [lL][eE][vV][eE][lL];
LIKE:         [lL][iI][kK][eE];
LIMIT:        [lL][iI][mM][iI][tT];
LSM:          [lL][sS][mM];
MAP:          [mM][aA][pP];
MAPPING:      [mM][aA][pP][pP][iI][nN][gG];
MATCHED:      [mM][aA][tT][cC][hH][eE][dD];
MATERIALIZED: [mM][aA][tT][eE][rR][iI][aA][lL][iI][zZ][eE][dD];
MERGE:        [mM][eE][rR][gG][eE];
MISSING:      [mM][iI][sS][sS][iI][nN][gG];
NAMESPACE:    [nN][aA][mM][eE][sS][pP][aA][cC][eE];
NEST:         [nN][eE][sS][tT];
NL:           [nN][lL];
NO:           [nN][oO];
NOT:          [nN][oO][tT];
NTH_VALUE:    [nN][tT][hH][_][vV][aA][lL][uU][eE];
NULL:         [nN][uU][lL][lL];
NULLS:        [nN][uU][lL][lL][sS];
NUMBER:       [nN][uN][mM][bB][eE][rR];
OBJECT:       [oO][bB][jJ][eE][cC][tT];
OFFSET:       [oO][fF][fF][sS][eE][tT];
ON:           [oO][nN];
OPTION:       [oO][pP][tT][iI][oO][nN];
OPTIONS:      [oO][pP][tT][iI][oO][nN][sS];
OR:           [oO][rR];
ORDER:        [oO][rR][dD][eE][rR];
OTHERS:       [oO][tT][hH][eE][rR][sS];
OUTER:        [oO][uU][tT][eE][rR];
OVER:         [oO][vV][eE][rR];
PARSE:        [pP][aA][rR][sS][eE];
PARTITION:    [pP][aA][rR][tT][iI][tT][iI][oO][nN];
PASSWORD:     [pP][aA][sS][sS][wW][oO][rR][dD];
PATH:         [pP][aA][tT][hH];
POOL:         [pP][oO][oO][lL];
PRECEDING:    [pP][rR][eE][cC][eE][dD][iI][nN][gG];
PREPARE:      [pP][rR][eE][pP][aA][rR][eE];
PRIMARY:      [pP][rR][iI][mM][aA][rR][yY];
PRIVATE:      [pP][rR][iI][vV][aA][tT][eE];
PRIVILEGE:    [pP][rR][iI][vV][iI][lL][eE][gG][eE];
PROCEDURE:    [pP][rR][oO][cC][eE][dD][uU][rR][eE];
PROBE:        [pP][rR][oO][bB][eE];
PUBLIC:       [pP][uU][bB][lL][iI][cC];
RANGE:        [rR][aA][nN][gG][eE];
RAW:          [rR][aA][wW];
READ:         [rR][eE][aA][dD];
REALM:        [rR][eE][aA][lL][mM];
REDUCE:       [rR][eE][dD][uU][cC][eE];
RENAME:       [rR][eE][nN][aA][mM][eE];
REPLACE:      [rR][eE][pP][lL][aA][cC][eE];
RESPECT:      [rR][eE][sS][pP][eE][cC][tT];
RETURN:       [rR][eE][tT][uU][rR][nN];
RETURNING:    [rR][eE][tT][uU][rR][nN][iI][nN][gG];
REVOKE:       [rR][eE][vV][oO][kK][eE];
RIGHT:        [rR][iI][gG][hH][tT];
ROLE:         [rR][oO][lL][eE];
ROLLBACK:     [rR][oO][lL][lL][bB][aA][cC][kK];
ROW:          [rR][oO][wW];
ROWS:         [rR][oO][wW][sS];
SATISFIES:    [sS][aA][tT][iI][sS][fF][iI][eE][sS];
SAVEPOINT:    [sS][aA][vV][eE][pP][oO][iI][nN][tT];
SCHEMA:       [sS][cC][hH][eE][mM][aA];
SCOPE:        [sS][cC][oO][pP][eE];
SELECT:       [sS][eE][lL][eE][cC][tT];
SELF:         [sS][eE][lL][fF];
SET:          [sS][eE][tT];
SHOW:         [sS][hH][oO][wW];
SOME:         [sS][oO][mM][eE];
START:        [sS][tT][aA][rR][tT];
STATISTICS:   [sS][tT][aA][tT][iI][sS][tT][iI][cC][sS];
STRING:       [sS][tT][rR][iI][nN][gG];
SYSTEM:       [sS][yY][sS][tT][eE][mM];
THEN:         [tT][hH][eE][nN];
TIES:         [tT][iI][eE][sS];
TO:           [tT][oO];
TRAN:         [tT][rR][aA][nN];
TRANSACTION:  [tT][rR][aA][nN][sS][aA][cC][tT][iI][oO][nN];
TRIGGER:      [tT][rR][iI][gG][gG][eE][rR];
TRUE:         [tT][rR][uU][eE];
TRUNCATE:     [tT][rR][uU][nN][cC][aA][tT][eE];
UNBOUNDED:    [uU][nN][bB][oO][uU][nN][dD][eE][dD];
UNDER:        [uU][nN][dD][eE][rR];
UNION:        [uU][nN][iI][oO][nN];
UNIQUE:       [uU][nN][iI][qQ][uU][eE];
UNKNOWN:      [uU][nN][kK][nN][oO][wW][nN];
UNNEST:       [uU][nN][nN][eE][sS][tT];
UNSET:        [uU][nN][sS][eE][tT];
UPDATE:       [uU][pP][dD][aA][tT][eE];
UPSERT:       [uU][pP][sS][eE][rR][tT];
USE:          [uU][sS][eE];
USER:         [uU][sS][eE][rR];
USING:        [uU][sS][iI][nN][gG];
VALIDATE:     [vV][aA][lL][iI][dD][aA][tT][eE];
VALUE:        [vV][aA][lL][uU][eE];
VALUED:       [vV][aA][lL][uU][eE][dD];
VALUES:       [vV][aA][lL][uU][eE][sS];
VIA:          [vV][iI][aA];
VIEW:         [vV][iI][eE][wW];
WHEN:         [wW][hH][eE][nN];
WHERE:        [wW][hH][eE][rR][eE];
WHILE:        [wW][hH][iI][lL][eE];
WINDOW:       [wW][iI][nN][dD][oO][wW];
WITH:         [wW][iI][tT][hH];
WITHIN:       [wW][iI][tT][hH][iI][nN];
WORK:         [wW][oO][rR][kK];
XOR:          [xX][oO][rR];

;;;;;;;;;
; RULES ;
;;;;;;;;;

statement-sequence = statement *( SEMICOLON statement ) [ SEMICOLON ]

statement = dcl-statement /
              ddl-statement /
              dml-statement /
              dql-statement /
              tcl-statement /
              utility-statement

ddl-statement = create-statement
                / drop-statement
                / other-statement

create-statement = create-scope
                   / create-collection
                   / create-primary-index
                   / create-index
                   / create-function

drop-statement = drop-scope
                 / drop-collection
                 / drop-primary-index
                 / drop-index
                 / drop-function

other-statement = alter-index
                  / build-index
                  / execute-function


create-scope = CREATE SCOPE [  namespace-ref COLON  ] bucket-ref DOT scope-ref [  IF NOT EXISTS  ]

create-collection = CREATE COLLECTION [  [  namespace-ref COLON  ] bucket-ref DOT scope-ref DOT  ]
                      collection-ref [  IF NOT EXISTS  ]



drop-scope = DROP SCOPE [  namespace-ref COLON  ] bucket-ref DOT scope-ref [  IF EXISTS  ]



drop-collection = DROP COLLECTION [  [  namespace-ref COLON  ] bucket-ref DOT scope-ref DOT  ]
                    collection-ref [  IF EXISTS  ]


create-primary-index = CREATE PRIMARY INDEX [ index-name ] [  IF NOT EXISTS  ]
                         ON keyspace-ref [ index-using ] [ index-with ]

index-using = USING GSI

index-with = WITH expr

create-index = CREATE INDEX index-name [  IF NOT EXISTS  ] ON keyspace-ref
                 LPAREN index-key [ lead-key-attribs ] [ 1*( COMMA index-key [ key-attribs ] ) ] RPAREN
                 [ index-partition ] [ where-clause ] [ index-using ] [ index-with ]

index-key = expr / array-expr

lead-key-attribs = index-order [ include-missing ] / include-missing [ index-order ]

key-attribs = index-order

include-missing = INCLUDE MISSING

index-order = ASC / DESC

array-expr = full-array-expr / simple-array-expr

full-array-expr = ( ALL / DISTINCT ) ARRAY expr
                    FOR var ( IN / WITHIN ) expr
                    *( COMMA var ( IN / WITHIN ) expr ) [  WHEN cond  ] END

simple-array-expr = ( ALL / DISTINCT ) expr

pairs-function = PAIRS LPAREN ( SELF / index-key-object ) RPAREN

index-key-object = expr

index-partition = PARTITION BY HASH LPAREN partition-key-expr
                    *( COMMA partition-key-expr ) RPAREN

partition-key-expr = expr


alter-index = ALTER INDEX ( index-path DOT index-name / index-name ON keyspace-ref )
                [ index-using ] index-with

build-index = BUILD INDEX ON keyspace-ref LPAREN index-term *( COMMA index-term) RPAREN
                [ index-using ]

index-term = index-name / subquery-expr


drop-primary-index = DROP PRIMARY INDEX [  IF EXISTS  ] ON keyspace-ref
                       [ index-using ]

drop-index = DROP INDEX ( index-path DOT index-name [  IF EXISTS  ] /
                index-name [  IF EXISTS  ] ON keyspace-ref ) [ index-using ]

index-path = keyspace-full / keyspace-prefix / keyspace-partial

keyspace-full = namespace-ref COLON bucket-ref DOT scope-ref DOT collection-ref

keyspace-prefix = [  namespace-ref COLON  ] bucket-ref

create-function = create-function-inline / create-function-external

create-function-inline = CREATE [  OR REPLACE  ] FUNCTION function-ref LPAREN [ params ] RPAREN
                           [  IF NOT EXISTS  ]
                           ( LBRACE body RBRACE / LANGUAGE INLINE AS body )

create-function-external = CREATE [  OR REPLACE  ] FUNCTION function-ref LPAREN [ params ] RPAREN
                             [  IF NOT EXISTS  ]
                             LANGUAGE JAVASCRIPT AS obj AT

function-ref = [  namespace-ref COLON [ bucket-ref DOT scope-ref DOT ]  ] identifier-ref

params = identifier-or-star *( COMMA identifier-or-star ) / ELLIPSIS

body = expr

obj = str

drop-function = DROP FUNCTION function-ref [  IF EXISTS  ]

execute-function = EXECUTE FUNCTION function-ref LPAREN [ expr *( COMMA expr ) ] RPAREN

dml-statement = delete-statement
                / insert-statement
                / merge-statement
                / update-statement
                / upsert-statement



delete-statement = DELETE FROM target-keyspace [ use-keys-clause ] [ where-clause ]
            [ limit-clause ] [ returning-clause ]

insert-statement = INSERT INTO target-keyspace ( insert-values / insert-select )
            [ returning-clause ]

insert-values = [  LPAREN [ PRIMARY ] KEY COMMA VALUE [ COMMA OPTIONS ] RPAREN  ] values-clause

values-clause = VALUES  LPAREN key-expr COMMA value-expr [  COMMA options  ] RPAREN
            *( COMMA [ VALUES ] LPAREN key-expr COMMA value-expr [  COMMA options  ] RPAREN )

insert-select = LPAREN [ PRIMARY ] KEY key-expr [  COMMA VALUE value-expr  ]
                   [  COMMA OPTIONS options  ] RPAREN select-statement


merge-statement = MERGE INTO ( ansi-merge / lookup-merge ) [ limit-clause ] [ returning-clause ]

ansi-merge = target-keyspace use-index-clause USING ansi-merge-source
               ansi-merge-predicate ansi-merge-actions

ansi-merge-source = ( merge-source-keyspace / merge-source-subquery / merge-source-expr )
                      [ ansi-join-hints ]

ansi-merge-predicate = ON expr

ansi-merge-actions = [ merge-update ] [ merge-delete ] [ ansi-merge-insert ]

ansi-merge-insert = WHEN NOT MATCHED THEN INSERT LPAREN [ KEY ] key-expr
                      [  COMMA [ VALUE ] value-expr  ] [  COMMA [ OPTIONS ] options  ] RPAREN [ where-clause ]

lookup-merge = target-keyspace USING lookup-merge-source lookup-merge-predicate
                 lookup-merge-actions

lookup-merge-source = merge-source-keyspace [ use-clause ] /
                        merge-source-subquery /
                        merge-source-expr

lookup-merge-predicate = ON [ PRIMARY ] KEY expr

lookup-merge-actions = [ merge-update ] [ merge-delete ] [ lookup-merge-insert ]

lookup-merge-insert = WHEN NOT MATCHED THEN INSERT expr [ where-clause ]

merge-source-keyspace = keyspace-ref [  [ AS ] alias  ]

merge-source-subquery = subquery-expr [ AS ] alias

merge-source-expr = expr [  [ AS ] alias  ]

merge-update = WHEN MATCHED THEN UPDATE [ set-clause ] [ unset-clause ] [ where-clause ]

merge-delete = WHEN MATCHED THEN DELETE [ where-clause ]

update-statement = UPDATE target-keyspace [ use-keys-clause ] [ set-clause ] [ unset-clause ]
            [ where-clause ] [ limit-clause ] [ returning-clause ]


upsert-statement = UPSERT INTO target-keyspace ( insert-values / insert-select )
            [ returning-clause ]


target-keyspace = keyspace-ref [  [ AS ] alias  ]

returning-clause = RETURNING *(result-expr (COMMA result-expr) /
                    (RAW / ELEMENT / VALUE) expr)

set-clause = SET ( path EQUAL expr [ update-for ] )
               *( COMMA (  path EQUAL expr [ update-for ] ) )

unset-clause = UNSET path [ update-for ] *(COMMA path [ update-for ])

update-for = *1(
				FOR [ name-var COLON ] var (IN / WITHIN) path
               *(COMMA [ name-var COLON ] var (IN / WITHIN) path)
		   	 ) [ WHEN cond ] END
;/* end::update-for[] */

key-expr = expr
value-expr = expr

;/* Data Query Language */

dql-statement = select-statement /
                  infer-statement /
                  update-statistics

;/***************
; * N1QL SELECT *
; ***************/

select-statement = select-term *( set-op select-term ) [ order-by-clause ] [ limit-clause ] [ offset-clause ]

select-term = subselect / LPAREN select-statement RPAREN

subselect = select-from / from-select

select-from = [ with-clause ] select-clause [ from-clause ] [ let-clause ] [ where-clause ] [ group-by-clause ] [ window-clause ]

from-select = [ with-clause ] from-clause [ let-clause ] [ where-clause ] [ group-by-clause ] [ window-clause ] select-clause

set-op = ( UNION / INTERSECT / EXCEPT ) [ ALL ]



with-clause = WITH alias AS LPAREN ( select-statement / expr ) RPAREN
                 *( COMMA alias AS LPAREN ( select-statement / expr ) RPAREN )

alias = identifier-ref



select-clause = SELECT [ hint-comment ] projection

projection = [  ALL / DISTINCT  ] *( result-expr ( COMMA result-expr ) /
               ( RAW / ELEMENT / VALUE ) expr [  [ AS ] alias  ] )

result-expr = [  path DOT  ] ASTERISK / expr [  [ AS ] alias  ]

path = identifier-ref *( LBRACKET expr RBRACKET ) *( DOT identifier-ref *( LBRACKET expr RBRACKET ) )



from-clause = FROM from-terms

from-terms = ( from-keyspace / from-subquery / from-generic )
               *( join-clause / nest-clause / unnest-clause ) *comma-separated-join

from-keyspace = keyspace-ref [ [ AS ] alias  ] [ use-clause ]

keyspace-ref = keyspace-path / keyspace-partial

keyspace-path = [  namespace-ref COLON  ] bucket-ref [  DOT scope-ref DOT collection-ref  ]

keyspace-partial = collection-ref

namespace-ref = identifier-ref

bucket-ref = identifier-ref

scope-ref = identifier-ref

collection-ref = identifier-ref

from-subquery = subquery-expr [ AS ] alias

subquery-expr = LPAREN select-statement RPAREN

from-generic = expr [  AS alias  ]



join-clause = ansi-join-clause / lookup-join-clause / index-join-clause



ansi-join-clause = [ ansi-join-type ] JOIN ansi-join-rhs ansi-join-predicate

ansi-join-type = INNER / ( LEFT / RIGHT ) [ OUTER ]

ansi-join-rhs = rhs-keyspace / rhs-subquery / rhs-generic

rhs-keyspace = keyspace-ref [  [ AS ] alias  ] [ ansi-join-hints ]

rhs-subquery = subquery-expr [ AS ] alias

rhs-generic = expr [  [ AS ] alias  ]

ansi-join-hints = use-hash-hint / use-nl-hint / multiple-hints

use-hash-hint = USE use-hash-term

use-hash-term = HASH LPAREN ( BUILD / PROBE ) RPAREN

use-nl-hint = USE use-nl-term

use-nl-term = NL

multiple-hints = USE ( ansi-hint-terms other-hint-terms /
                           other-hint-terms ansi-hint-terms )

ansi-hint-terms = use-hash-term / use-nl-term

other-hint-terms = use-index-term / use-keys-term

ansi-join-predicate = ON expr



lookup-join-clause = [ lookup-join-type ] JOIN lookup-join-rhs lookup-join-predicate

lookup-join-type = INNER / ( LEFT [ OUTER ] )

lookup-join-rhs = keyspace-ref [  [ AS ] alias  ]

lookup-join-predicate = ON [ PRIMARY ] KEYS expr



index-join-clause = [ index-join-type ] JOIN index-join-rhs index-join-predicate

index-join-type = INNER / ( LEFT [ OUTER ] )

index-join-rhs = keyspace-ref [  [ AS ] alias  ]

index-join-predicate = ON [ PRIMARY ] KEY expr FOR alias



comma-separated-join = COMMA ( rhs-keyspace / rhs-subquery / rhs-generic )



nest-clause = ansi-nest-clause / lookup-nest-clause / index-nest-clause



ansi-nest-clause = [ ansi-nest-type ] NEST ansi-nest-rhs ansi-nest-predicate

ansi-nest-type = INNER / ( LEFT [ OUTER ] )

ansi-nest-rhs = keyspace-ref [  [ AS ] alias  ]

ansi-nest-predicate = ON expr



lookup-nest-clause = [ lookup-nest-type ] NEST lookup-nest-rhs lookup-nest-predicate

lookup-nest-type = INNER / ( LEFT [ OUTER ] )

lookup-nest-rhs = keyspace-ref [  [ AS ] alias  ]

lookup-nest-predicate = ON KEYS expr



index-nest-clause = [ index-nest-type ] NEST index-nest-rhs index-nest-predicate

index-nest-type = INNER / ( LEFT [ OUTER ] )

index-nest-rhs = keyspace-ref [  [ AS ] alias  ]

index-nest-predicate = ON KEY expr FOR alias



unnest-clause = [ unnest-type ] ( UNNEST / FLATTEN ) expr [  [ AS ] alias  ]

unnest-type = INNER / ( LEFT [ OUTER ] )



use-clause = use-keys-clause / use-index-clause

use-keys-clause = USE use-keys-term

use-keys-term = [ PRIMARY ] KEYS expr

use-index-clause = USE use-index-term

use-index-term = INDEX LPAREN index-ref *( COMMA index-ref ) RPAREN

index-ref = [ index-name ] [ index-type ]

index-name = identifier-ref

index-type = USING ( GSI / FTS )



let-clause = LET alias EQUAL expr *( COMMA alias EQUAL expr )



where-clause = WHERE cond

cond = expr

group-by-clause = GROUP BY group-term *( COMMA group-term )
                    [ letting-clause ] [ having-clause ] / letting-clause

group-term = expr [  [ AS ] alias  ]

letting-clause = LETTING alias EQUAL expr *( COMMA alias EQUAL expr )

having-clause = HAVING cond



window-clause = WINDOW window-declaration *( COMMA window-declaration )

window-declaration = window-name AS LPAREN window-definition RPAREN

window-name = identifier-ref

window-definition = [ window-ref ] [ window-partition-clause ] [ window-order-clause ]
                      [ window-frame-clause ]

window-ref = identifier-ref

window-partition-clause = PARTITION BY expr *( COMMA expr )

window-order-clause = ORDER BY ordering-term *( COMMA ordering-term )

window-frame-clause = ( ROWS / RANGE / GROUPS ) window-frame-extent
                        [ window-frame-exclusion ]

window-frame-extent = UNBOUNDED PRECEDING / CURRENT ROW /
                        BETWEEN ( UNBOUNDED PRECEDING / CURRENT ROW / ( PRECEDING / FOLLOWING ) )
                            AND ( UNBOUNDED FOLLOWING / CURRENT ROW / ( PRECEDING / FOLLOWING ) )

window-frame-exclusion = EXCLUDE ( CURRENT ROW / GROUP / TIES / NO OTHERS )



order-by-clause = ORDER BY ordering-term *( COMMA ordering-term )

ordering-term = expr [  ASC / DESC  ] [ NULLS ( FIRST / LAST ) ]



limit-clause = LIMIT expr



offset-clause = OFFSET expr


hint-comment = block-hint-comment / line-hint-comment

block-hint-comment = BLOCK_HINT_OPEN hints COMMENT_CLOSE

line-hint-comment = LINE_HINT_OPEN hints

hints = simple-hint-sequence / json-hint-object

simple-hint-sequence = 1*simple-hint

simple-hint = ordered-hint-simple
              / gsi-hint-simple
              / fts-hint-simple
              / hash-hint-simple
              / nl-hint-simple

ordered-hint-simple = ORDERED

gsi-hint-simple = INDEX LPAREN keyspace-statement RPAREN

keyspace-statement = KEYSPACE identifier-ref

fts-hint-simple = INDEX_FTS LPAREN keyspace-statement RPAREN

nl-hint-simple = USE_NL LPAREN 1*( keyspace-statement ) RPAREN

hash-hint-simple = USE_HASH LPAREN 1*( keyspace-statement [ SLASH ( BUILD / PROBE ) ] ) RPAREN

json-hint-object = LBRACE json-hint *(COMMA json-hint ) RBRACE

json-hint = ordered-hint-json
             / gsi-hint-json
             / fts-hint-json
             / hash-hint-json
             / nl-hint-json

ordered-hint-json = QUOTED_ORDERED COLON TRUE

gsi-hint-json = QUOTED_INDEX COLON ( index-array / index-object )

fts-hint-json = QUOTED_INDEX_FTS COLON ( index-array / index-object )

nl-hint-json = QUOTED_USE_NS COLON ( keyspace-array / keyspace-object )

hash-hint-json = QUOTED_USE_HASH  ( hash-array / hash-object )

index-array = LBRACKET index-object *( COMMA index-object ) RBRACKET

index-object = LBRACE keyspace-property COMMA indexes-property RBRACE

indexes-property = QUOTED_INDEXES COLON ( NULL
                                     / DQUOTE index DQUOTE
                                     / LBRACKET DQUOTE index DQUOTE *( COMMA DQUOTE index DQUOTE ) RBRACKET )

keyspace-array = LBRACKET keyspace-object *( COMMA keyspace-object ) RBRACKET

keyspace-object = LBRACE keyspace-property RBRACE

keyspace-property = ( QUOTED_KEYSPACE / QUOTED_ALIAS ) COLON DQUOTE keyspace-statement DQUOTE

hash-array = LBRACKET hash-object *( COMMA hash-object ) RBRACKET

hash-object = LBRACE keyspace-property [  COMMA option-property  ] RBRACE

option-property = QUOTED_OPTION COLON ( QUOTED_BUILD / QUOTED_PROBE / NULL )

;;/***************
;; * Expressions *
;; ***************/
;
expr = (
            (
                path /
                json-value /
                literal /
                identifier-ref /
                nested-expr /
                function-call /
                subquery-expr
            ) *(
                comparison-term /
                arithmetic-term /
                concatenation-term /
                logical-term /
                collection-expr
            )
         ) /
         case-expr



literal = str / nbr / bool / NULL / MISSING

str = double-quoted-string / single-quoted-string

double-quoted-string = DQUOTE *double-quoted-string-character DQUOTE

single-quoted-string = QUOTE *single-quoted-string-character QUOTE

double-quoted-string-character = (
                                        ESCAPE_SEQUENCE
                                        / ESCAPED_DQUOTE
                                       / STRING_CHAR
                                   )

single-quoted-string-character = (
                                        ESCAPE_SEQUENCE
                                        / ESCAPED_QUOTE
                                        / STRING_CHAR
                                   )

bool = TRUE / FALSE

identifier-or-star = identifier-ref / ASTERISK

identifier-ref = IDENTIFIER / escaped-identifier

escaped-identifier = BACKTICK IDENTIFIER BACKTICK

arithmetic-term = PLUS expr /
                    ASTERISK expr /
                    SLASH expr /
                    PERCENT expr /
                    MINUS_SIGN expr

comparison-term = relational-expr /
                    between-expr /
                    like-expr /
                    is-expr

relational-expr = DOUBLE_EQUAL expr /
                    EQUAL expr /
                    NOT_EQUAL expr /
                    LESSTHAN_OR_MORETHAN expr /
                    MORETHAN expr /
                    MORETHAN_OR_EQUAL expr /
                    LESSTHAN expr /
                    LESSTHAN_OR_EQUAL expr

between-expr = [ NOT ] BETWEEN expr AND expr

like-expr = [ NOT ] LIKE expr

is-expr = IS [ NOT ] NULL /
            IS [ NOT ] MISSING /
            IS [ NOT ] VALUED



concatenation-term = DBLPIPE expr



logical-term = and-expr / or-expr / not-expr

and-expr = AND cond

or-expr = OR cond

not-expr = NOT cond



case-expr = simple-case-expr / searched-case-expr

simple-case-expr = CASE expr 1*(WHEN expr THEN expr) [ ELSE expr ] END

searched-case-expr = CASE 1*(WHEN cond THEN expr) [ ELSE expr ] END



collection-expr = exists-expr / in-expr / within-expr / range-cond

exists-expr = EXISTS expr

in-expr = [ NOT ] IN expr

within-expr = [ NOT ] WITHIN expr

range-cond = ( ( ANY / SOME ) [  AND EVERY  ] / EVERY ) range-expr SATISFIES cond END

range-expr = [  name-var COLON  ] var ( IN / WITHIN ) expr
            *( COMMA [  name-var COLON  ] var ( IN / WITHIN ) expr )

var = identifier-ref
name-var = identifier-ref





array-expr = LBRACKET [ expr *( COMMA expr ) ] RBRACKET



nested-expr = field-expr / element-expr / slice-expr

field-expr = DOT ( identifier-ref / ( ( escaped-identifier / LBRACKET expr RBRACKET ) 'i'? ) )

element-expr = LBRACKET expr RBRACKET

slice-expr = LBRACKET expr COLON [ expr ] RBRACKET


function-call = (builtin-function /
                  ordinary-function /
                  aggregate-function /
                  window-function) [  DOT path  ]

function-name = identifier-ref
aggregate-function-name = FUNCS / identifier-ref
window-function-name = FUNCS / identifier-ref


ordinary-function = function-name LPAREN [ expr *( COMMA expr ) ] RPAREN

builtin-function = FUNCS LPAREN [ expr *( COMMA expr ) ] RPAREN

aggregate-function = aggregate-function-name LPAREN ( [ aggregate-quantifier ] expr /
                       [  path DOT  ] ASTERISK ) RPAREN [ filter-clause ] [ over-clause ]

aggregate-quantifier = ALL / DISTINCT

filter-clause = FILTER LPAREN WHERE cond RPAREN

window-function = window-function-name LPAREN window-function-arguments RPAREN
                    [ window-function-options ] over-clause

window-function-arguments = [  expr [  COMMA expr [  COMMA expr  ]  ]  ]

window-function-options = [ nthval-from ] [ nulls-treatment ]

nthval-from = FROM ( FIRST / LAST )

nulls-treatment = ( RESPECT / IGNORE ) NULLS

over-clause = OVER ( LPAREN window-definition RPAREN / window-ref )



subquery-expr = LPAREN select-statement RPAREN


;/************
; * Comments *
; ************/

comment = block-comment

block-comment = BLOCK_COMMENT_OPEN *(  LF ) COMMENT_CLOSE



tcl-statement = begin-transaction
                / set-transaction
                / savepoint-statement
                / rollback-transaction
                / commit-transaction

begin-transaction = ( BEGIN / START ) ( WORK / TRAN / TRANSACTION )
                      [  ISOLATION LEVEL READ COMMITTED  ]

set-transaction = SET TRANSACTION ISOLATION LEVEL READ COMMITTED

savepoint-statement = SAVEPOINT savepointname

rollback-transaction = ROLLBACK [  WORK / TRAN / TRANSACTION  ]
                       [  TO SAVEPOINT savepointname  ]

commit-transaction = COMMIT [  WORK / TRAN / TRANSACTION  ]

savepointname = identifier-ref



utility-statement = advise-statement
                    / explain-statement

advise-statement = ADVISE [ INDEX ] ( select-statement / update-statement / delete-statement / merge-statement )

explain-statement = EXPLAIN statement

infer-statement = INFER [  COLLECTION / KEYSPACE  ] keyspace-ref [  WITH options  ]


;/***********************
; * Prepared Statements *
; ***********************/


name = identifier-ref
parameters = array-expr

;/**************
; * Statistics *
; **************/

update-statistics = update-statistics-expr / update-statistics-index / update-statistics-delete

update-statistics-expr = ( UPDATE STATISTICS [ FOR ] /
                             ANALYZE [  KEYSPACE / COLLECTION ] )
                             keyspace-ref LPAREN index-key *( COMMA index-key ) RPAREN [ index-with ]

update-statistics-index = ( UPDATE STATISTICS FOR / ANALYZE )
                              index-clause [ index-using ]  [ index-with ]

index-clause = INDEX ( index-path DOT index-name / index-name ON keyspace-ref )

update-statistics-indexes = ( UPDATE STATISTICS [ FOR ] /
                                ANALYZE [  KEYSPACE / COLLECTION ] )
                                keyspace-ref indexes-clause [ index-using ] [ index-with ]

indexes-clause = INDEX ( LPAREN ( index-name *( COMMA index-name ) / subquery-expr ) RPAREN /
                             ALL )

update-statistics-delete = ( UPDATE STATISTICS [ FOR ] /
                               ANALYZE [  KEYSPACE / COLLECTION ] )
                               keyspace-ref delete-clause

delete-clause = DELETE ( delete-expr / delete-all )

delete-expr = [ STATISTICS ] LPAREN index-key *( COMMA index-key ) RPAREN

delete-all = ALL / STATISTICS

;/* Data Control Language */

dcl-statement = grant-statement
                / revoke-statement

;/* tag::grant[] */
grant-statement = GRANT role *( COMMA role ) [ ON keyspace-ref *( COMMA keyspace-ref ) ]
          TO user *( COMMA user )
;/* end::grant[] */

;/* tag::revoke[] */
revoke-statement = REVOKE role *( COMMA role ) [ ON keyspace-ref *( COMMA keyspace-ref ) ]
           FROM user *( COMMA user )
;/* end::revoke[] */

role = identifier-ref
user = identifier-ref

json-value = json-object / json-array

json-array = LBRACKET [ expr *(COMMA expr) ] RBRACKET

json-object = LBRACE [ json-field *(COMMA json-field) ] RBRACE

json-field = str COLON expr