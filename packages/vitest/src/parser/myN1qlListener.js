/*
Copyright 2021-Present Couchbase, Inc.

Use of this software is governed by the Business Source License included in
the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
file, in accordance with the Business Source License, use of this software will
be governed by the Apache License, Version 2.0, included in the file
licenses/APL2.txt.
*/

/* eslint-disable */

/*
 * This is a listener for the N1QL parser generated by analyzing the goyacc N1QL parser.
 */

import antlr4 from 'antlr4';
import n1qlLexer from './antlr/n1qlLexer.js';
import n1qlParser from './antlr/n1qlParser.js';
import n1qlListener from './antlr/n1qlListener.js';
//import * as fs from 'fs';

const { CommonTokenStream, InputStream } = antlr4;

class myN1qlListener extends n1qlListener {

  constructor(currentParseResult) {
    super();
    this.currentParseResult = currentParseResult;
  }

  exitEveryRule(ctx) {
    super.exitEveryRule(ctx);
  }

  // Keyspaces from SELECT statements

  exitFrom_term(ctx) {
    super.exitFrom_term(ctx);
  }

  exitSimple_from_term(ctx) {
    const keyspace = ctx.expr().children.map(c => c.getText()).filter(s => s !== '.');
    this.currentParseResult.keyspaces.push(keyspace);
  }

  // Exit a parse tree produced by n1qlParser#expr.
  exitExpr(ctx) {
    let expr = ctx.expr();
    let c_expr = ctx.c_expr();
    let DOT = ctx.DOT();
    let IDENT = ctx.IDENT();
    let LBRACKET = ctx.LBRACKET();

    if (DOT && IDENT)
      this.currentParseResult.path_expr.push(IDENT.getText());
    if (LBRACKET)
      this.currentParseResult.path_expr.push('[]');
  }

  // Exit a parse tree produced by n1qlParser#c_expr.
  exitC_expr(ctx) {
    var IDENT = ctx.IDENT();
    var IDENT_ICASE = ctx.IDENT_ICASE();
    var SELF = ctx.SELF();
    // whenever we see an IDENT, it is a field name used in an expression
    if (IDENT || IDENT_ICASE) {
      this.currentParseResult.newPath(ctx.getText());
    }
  }
}

class MyParseCancellationException extends Error{
  constructor(line,column,message) {
    super()
    this.line = line;
    this.column = column;
    this.message = message;
    //Error.captureStackTrace(this, MyParseCancellationException);
  }
}

class myErrorListener extends antlr4.error.ErrorListener {
  constructor() {
    super();
  }

  syntaxError(recognizer, symbol, line, column, message, payload) {
    console.log("\n\n\nGot error: " + symbol + "," + line + "," + column + "," + message + "," + payload);
    throw new MyParseCancellationException(line,column,message);
  }
}

class myParseResult {
  constructor() {
    this.path_expr = [];
    this.all_paths_used = [];
    this.functions_used = [];
    this.stmt_category = 0; // explain, prepare, advise, execute, or regular stmtm
    this.stmt = 0; // top level statement: select, update, delete, merge, upsert
  }

  newPath(pathElement) {
    if (this.path_expr.length > 0)
      this.all_paths_used.push(this.path_expr);

    this.path_expr = [pathElement];
  }

  finish() {
    // output any outstanding path expressions
    if (this.path_expr.length > 0) {
      this.all_paths_used.push(this.path_expr);
      this.path_expr = [];
    }

    switch (this.stmt_category) {
      case n1qlParser.RULE_stmt: this.isStatement = true; break;
      case n1qlParser.RULE_advise: this.isAdvise = true; break;
      case n1qlParser.RULE_explain: this.isExplain = true; break;
      case n1qlParser.RULE_prepare: this.isPrepare = true; break;
      case n1qlParser.RULE_execute: this.isExecute = true; break;
    }

    switch (this.stmt) {
      case n1qlParser.RULE_select_stmt: this.isSelect = true; break;
      case n1qlParser.RULE_insert: this.isInsert = true; break;
      case n1qlParser.RULE_update: this.isUpdate = true; break;
      case n1qlParser.RULE_upsert: this.isUpsert = true; break;
      case n1qlParser.RULE_delete_: this.isDelete = true; break;
      case n1qlParser.RULE_merge: this.isMerge = true; break;
      case n1qlParser.RULE_index_stmt: this.isIndex = true; break;
      case n1qlParser.RULE_scope_stmt: this.isScope = true; break;
      case n1qlParser.RULE_collection_stmt: this.isCollection = true; break;

    }

  }
}


//
// Parse a string containing one or more N1QL queries (separated by semicolons)
//
// returns an array of results, which are either a myParseResult or a parse error
//

function parse(n1ql) {


  return(currentParseResults);
}

var N1qlParser = {
  parse: parse,
};

export default N1qlParser;